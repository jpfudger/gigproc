#!/usr/bin/python
import sys
import os
from re import match, search, IGNORECASE, sub, findall
from datetime import date
from glob import glob

display_max = 300
root = '/home/jpf/gigproc/'

# Utilities

def print_summary(gigs,n):
    artists = unique_artists(gigs)
    venues = unique_venues(gigs)
    years = unique_years(gigs)
    n_gigs = str(len(gigs))
    n_venues = " " + str(len(venues))
    n_artists = str(len(artists))
    n_years = " " + str(len(years))
    #today = date.today().strftime('%d %B %Y')

    print ( ""
     "\n          /---------------------\ "
     "\n          |                     | "
     "\n          |     %s years       | "
     "\n          |     %s gigs        | "
     "\n          |     %s venues      | "
     "\n          |     %s artists     | "
     "\n          |                     | "
     "\n          \---------------------/ "
     "\n"
     ) % ( n_years, n_gigs, n_venues, n_artists )

    for i in range(0,n-1):
        print '{0:3d} {1:30s} {2:3d} {3:30s}' \
            . format( artists[i][1], artists[i][0], venues[i][1], venues[i][0])

    print ""

def print_gig(gig):
    print "======================================"
    print gig['date'].strftime('    Date: %d %B, %Y')
    print "   Venue: " + gig['venue']
    for s in gig['sets']:
        print "  Artist: " + s['artist']
        for song in s['setlist']:
            print "          > " + song

def match_dates(d1,d2):
    matched = False
    if d1 != None and d2 != None:
        if d1.year == d2.year and d1.month == d2.month and d1.day == d2.day:
            matched = True
    return matched

def summarise_query_result(gigs,full):
    gigs.sort(key=lambda x: x['id'])
    for gig in gigs:
        if full:
            print_gig(gig)
        else:
            date = gig['date'].strftime('%d %B, %Y')
            venue = gig['venue']
            artist_list = [ s['artist'] for s in gig['sets'] ]
            # artists = " + ".join(artist_list)
            artists = artist_list[0]
            if len(artist_list) > 1:
                artists += ' + ' + artist_list[1]
            if len(artist_list) > 2:
                artists += ' + ... '
            ident = '[' + gig['id'] + ']'
            sys.stdout.write('\n {0:8s} {1:20s} {2:30s} {3:50s}' . format( ident, date, venue, artists))
    return

# Functions to build gig data:

def process_song_name(line):
    splits = line.split('---')
    medley = match( '^\s+', line )  # if the line is indented, it's part of a medley
    song = splits[0]
    song = sub( r"\s*---.*$", '', song)
    song = sub( r"\s*\*+\s*$", '', song)
    song = sub( r"\s*\^+\s*$", '', song)
    song = sub( r"\s*\~+\s*$", '', song)
    song = ' '.join(w[0].upper() + w[1:] for w in song.split())
    m_empty = match('^\s*$', song)

    if m_empty:
        return None, None
    else:
        flags = []
        if len(splits) > 1 and match( '.*{.*', splits[1] ):
            flags = findall( '{([0-9A-Za-z ]+)}', splits[1])
        if medley:
            flags.append( 'medley' )
        return song, flags

def get_data_from_file(path):
    gigs = []
    current = {}
    level = 0
    count = 0
    commented = False
    with open(path) as f:
        lines = f.read().splitlines()
    for line in lines:
        mopen = match('^\{\{\{ (.*)',line)
        mclose = match('^\}\}\}',line)
        mc = match('^\{\{\{\s*---',line)
        if mc:
            commented = True
        if mopen:
            level += 1
            m1 = match('^(\d\d)\.(\d\d)\.(\d\d\d\d) \[(.*)\]$',mopen.group(1))
            if commented:
                pass
            elif m1:
                count += 1
                year  = int(m1.group(3))
                month = int(m1.group(2))
                day   = int(m1.group(1))
                ident = ''.join(list(str(year))[2:4]) + '{0:02d}'.format(count)
                current['id']    = ident
                current['date']  = date( year, month, day )
                current['venue'] = m1.group(4)
                current['sets']  = []
            else:
                this_set = {}
                this_set['setlist'] = []
                this_set['flags'] = []
                this_set['artist'] = mopen.group(1)
                current['sets'].append(this_set)
        elif mclose:
            level -= 1
            if level == 0 and not commented:
                if current['date'] <= date.today():
                    gigs.append(current)
                current = {}
        elif level == 2:
            # Append song to last set of current gig:
            song, flags = process_song_name(line)
            if song != None:
                current['sets'][-1]['setlist'].append(song)
                current['sets'][-1]['flags'].append(flags)
        else:
            pass

    return gigs

def build_gig_data(top):
    gigs = []
    for f in glob(top + '/*.gigs'):
        #print f
        gigs += get_data_from_file(f)
    return gigs

# Queries on gig data:

def unique_artists(gigs):
    raw_artists = []
    for gig in gigs:
        raw_artists += [ s['artist'] for s in gig['sets'] ]
    artists = list(set(raw_artists))
    count = [ raw_artists.count(a) for a in artists ]
    zipped = zip( artists, count )
    zipped.sort(key=lambda x: ( -x[1], x[0] ), reverse=True )
    zipped.reverse()
    return zipped

def unique_venues(gigs):
    raw_venues = ([ g["venue"] for g in gigs])
    venues = list(set(raw_venues))
    count = [ raw_venues.count(v) for v in venues ]
    zipped = zip( venues, count )
    zipped.sort(key=lambda x: ( -x[1], x[0] ), reverse=True )
    zipped.reverse()
    return zipped

def unique_years(gigs):
    raw_years = [ g["date"].year for g in gigs ]
    years = list(set(raw_years))
    years.sort()
    count = [ raw_years.count(y) for y in years ]
    zipped = zip( years, count )
    zipped.sort(key=lambda x: x[1])
    zipped.reverse()
    return zipped

def extract_sets(gigs):
    for gig in gigs:
        print gig['date']

def search_gigs(gigs,query):
    results = []
    for gig in gigs:
        if query['id'] == None:
            date = gig['date'].strftime('%d %B, %Y')
            if query['date'] != None and search(query['date'],date,IGNORECASE):
                #print "Matched date."
                results.append(gig)
            elif query['venue'] != None and search(query['venue'],gig['venue'],IGNORECASE):
                # gig['venue'] == query['venue']: 
                #print "Matched venue."
                results.append(gig)
            else:
                for s in gig['sets']:
                    if query['artist'] != None and search(query['artist'],s['artist'],IGNORECASE):
                        #print "Matched artist."
                        # s['artist'] == query['artist']:
                        results.append(gig)
                    else:
                        for song in s['setlist']:
                            if query['song'] != None and search(query['song'],song,IGNORECASE):
                                #print "Matched song."
                                results.append(gig)
                    #elif query['song'] in s['setlist']:
        elif query['id'] == gig['id']:
            results.append(gig)
            break
    return results

# HTML Generation

def generate_html_setlist(gig):
    lines = [ '<html>', '<head>',
              '<link rel="stylesheet" type="text/css" href="../style.css">',
              '<head>'
              '<body class=setlist style="background-image:url(\'' 
                    + 'bhi13.jpg' + '\'); image-width:40%;">',
              '<div class=sl_tit>',
              gig['sets'][0]['artist'] + ' <br> ' + gig['venue'] 
                    + ' <br> ' + gig['date'].strftime('%A, %d %B, %Y'),
              '</div>', '<ol>']
    for song in gig['sets'][0]['setlist']:
        if not song.strip():
            lines.append('<br> <br>')
        else:
            lines.append( '<li> ' + song )
    lines += [ '</ol>', '</body>', '</html>', ]
    return lines

def generate_html_list(liszt):
    # Used to generate venue/artist lists.
    lines = [ '<html>', '<head>',
              '<link rel="stylesheet" type="text/css" href="../style.css">',
              '</head>', '<body>', '<ul>']
    for (x,c) in liszt:
        element = '<li> <div class=white>' + str(c) + '</div>'
        if c > 1:
            element += '<div class=times>&times;' + str(c) + '</div></li>'
        lines.append(element)
    lines.append( [ '</ul>', '</body>', '</html>' ] )
    return lines

def generate_html_files(gigs,head):
    for gig in gigs:
        fname = head + gig['date'].strftime('%y%m%d') + '.html'
        lines = generate_html_setlist(gig)
        with open(fname,'w') as f:
            for line in lines:
                f.write("%s\n" % line)

    with open(head+'venues.html','w') as f:
        for line in generate_html_list(unique_venues(gigs)):
            f.write("%s\n" % line)

    with open(head+'artists.html','w') as f:
        for line in generate_html_list(unique_artists(gigs)):
            f.write("%s\n" % line)

    for (y,c) in unique_years(gigs):
        print "Gigs in %d:" % y
        for gig in gigs:
            if gig['date'].year == y:
                print gig['sets'][0]['artist']
                # Need to order by date

    return

# Songs by artist

def unique_songs_of_artist(gigs,artist):
    raw_songs = []
    for gig in gigs:
        for s in gig['sets']:
            # look for song in artist's main set:
            if search(artist, s['artist'], IGNORECASE):
                for song in s['setlist']:
                    got = False
                    for got_song in raw_songs:
                        if got_song['song'] == song:
                            got_song['events'].append(gig['id'])
                            got = True
                    if not got:
                        raw_songs.append( { 'song': song, 'events': [ gig['id'] ] } )
            else:
                # look for song in other sets for which the artist is flagged:
                for song, flags in zip( s['setlist'], s['flags'] ):
                    flagged = False
                    for flag in flags:
                        if search( artist, flag, IGNORECASE ):
                            flagged = True
                    if flagged:
                        got = False
                        for got_song in raw_songs:
                            if got_song['song'] == song:
                                got_song['events'].append(gig['id'])
                                got = True
                        if not got:
                            raw_songs.append( { 'song': song, 'events': [ gig['id'] ] } )

    raw_songs.sort(key=lambda x: ( -len(x['events']), x['song'] ), reverse=True )
    raw_songs.reverse()
    return raw_songs

    #count = [ raw_songs.count(s) for s in songs ]
    #zipped = zip( songs, count )
    #zipped.sort(key=lambda x: x[1])
    #zipped.reverse()
    #return zipped 

def artist_stats(gigs,artist):
    unique_songs = unique_songs_of_artist( gigs, artist )

    raw_events = []
    for song in unique_songs:
        raw_events += song['events']

    events = list(set(raw_events))
    events.sort()

    print "\n\n Profiling %d unique songs from %d events by %s:\n"  \
        % (len(unique_songs), len(events), artist)

    for song in unique_songs:
        event_string = ""
        for event in events:
            if event in song['events']:
                event_string += 'X'
            else:
                event_string += '-'
        print '{0:3d} {1:50s} {2:30s}' \
            . format( len(song['events']), song['song'], event_string )

# Main

def print_help():
    print ( " Optional args:\n"
            " \n"
            " -a -artist\n"
            " -v -venue\n"
            " -s -song\n"
            " -d -date\n"
            " -i -id\n"
            )
    return

def process_args(args):
    # Converts user args to a search query
    query = { 'date'  : None,
              'venue' : None,
              'artist': None,
              'song'  : None,
              'id'    : None,
              'stats' : False,   # whether to build song_stats 
              }
    n_songs = 25
    empty = True
    for i in range(0, len(args)):
        if args[i] == "-artist" or args[i] == "-a":
            query['artist'] = args[i+1]
            empty = False
        elif args[i] == "-venue" or args[i] == "-v":
            query['venue'] = args[i+1]
            empty = False
        elif args[i] == "-song" or args[i] == "-s":
            query['song'] = args[i+1]
            empty = False
        elif args[i] == "-date" or args[i] == "-d":
            query['date'] = args[i+1]
            empty = False
        elif args[i] == "-id" or args[i] == "-i":
            query['id'] = args[i+1]
            empty = False
        elif args[i] == "-stats":
            query['stats'] = True
            empty = False
        elif args[i] == "-max" or args[i] == "-m":
            n_songs = int(args[i+1])

    if empty:
        query = None

    return query, n_songs

def main():
    cwd = os.getcwd()
    os.chdir(root)
    gigs = build_gig_data(root)
    args = sys.argv[1:]
    query, n_songs = process_args(args)
    if not query:
        print_summary(gigs,n_songs)
    elif len(args) == 1 and args[0] == "-help":
        print_help()
    elif len(args) == 1 and args[0] == "-html":
        generate_html_files(gigs,'./html/')
    elif query:
        results = search_gigs(gigs,query)
        print "\n %d matching events." % len(results)
        # print results
        summarise_query_result(results,query['id'] != None)
    else:
        print "Unprocessed option"

    if query and query['stats'] and query['artist']:
        artist_stats( gigs, query['artist'] )

    print "\n"

    os.chdir(cwd)

main()

